<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Press → Forward, Release → Reverse</title>
  <style>
    html, body { margin: 0; height: 100%; background: transparent; }
    body { display: grid; place-items: center; }

    .wrap { width: min(360px, 90vw); }
    .stage {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      background: #000; /* black fallback: no white flash */
      touch-action: manipulation;
      user-select: none;
    }

    /* Keep a stable layout + no intrinsic-size surprises */
    video {
      width: 100%;
      height: auto;
      display: block;
      background: #000;
    }

    /* Stack the two videos; only one is visible at a time */
    #vF, #vR {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: 0;
      pointer-events: none; /* don't steal pointer events */
    }
    #vF.is-on, #vR.is-on { opacity: 1; }

    /* This invisible sizer video establishes the stage height */
    #sizer {
      position: relative;
      opacity: 0;
      pointer-events: none;
    }

    .hint {
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity: 0.7;
      margin-top: 8px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage">
      <!-- sizer keeps a consistent height based on the media aspect ratio -->
      <video id="sizer" muted playsinline preload="metadata"></video>

      <!-- stacked playback videos -->
      <video id="vF" muted playsinline preload="auto"></video>
      <video id="vR" muted playsinline preload="auto"></video>
    </div>
    <div class="hint">Press / hold to play → release to rewind</div>
  </div>

  <script>
    // Add your 5–10 animation pairs here
    const ANIMS = [
      { fwd: "assets/anim1_fwd.mp4", rev: "assets/anim1_rev.mp4" },
      // { fwd: "assets/anim2_fwd.mp4", rev: "assets/anim2_rev.mp4" },
    ];

    const stage = document.getElementById("stage");
    const sizer = document.getElementById("sizer");
    const vF = document.getElementById("vF");
    const vR = document.getElementById("vR");

    let current = null;
    let duration = null;
    let holding = false;

    function pickRandomAnim() {
      return ANIMS[Math.floor(Math.random() * ANIMS.length)];
    }

    function once(el, evt) {
      return new Promise(res => el.addEventListener(evt, res, { once: true }));
    }

    async function ensureFrame(el) {
      // Wait until the browser has something paintable
      const canplayP = once(el, "canplay");
      const seekedP = once(el, "seeked");
      await Promise.race([canplayP, seekedP]).catch(() => {});
      if (typeof el.requestVideoFrameCallback === "function") {
        await new Promise(res => el.requestVideoFrameCallback(() => res()));
      } else {
        await new Promise(r => setTimeout(r, 20));
      }
    }

    async function loadPair(anim) {
      current = anim;

      // Load forward + reverse + the invisible sizer (to lock aspect/height)
      vF.src = anim.fwd;
      vR.src = anim.rev;
      sizer.src = anim.fwd;

      vF.load(); vR.load(); sizer.load();

      await once(vF, "loadedmetadata");
      duration = vF.duration;

      // Prime both at time 0 so first interaction is instant
      vF.currentTime = 0;
      vR.currentTime = 0;

      // Make sure the stage has a stable height before showing anything
      await ensureFrame(sizer);
    }

    function show(which) {
      // which: "F" or "R"
      vF.classList.toggle("is-on", which === "F");
      vR.classList.toggle("is-on", which === "R");
    }

    async function playForwardFromStart() {
      const anim = pickRandomAnim();
      await loadPair(anim);

      // Start forward
      vR.pause();
      vF.pause();
      vF.currentTime = 0;

      show("F");
      await ensureFrame(vF);

      await vF.play(); // user gesture (pointerdown)
    }

    async function playReverseFromMirroredTime() {
      if (!current || !duration) return;

      const t = Math.min(Math.max(vF.currentTime || 0, 0), duration);
      const mirrored = Math.max(0, Math.min(duration, duration - t));

      vF.pause();
      vR.pause();

      // Seek reverse then show it
      vR.currentTime = mirrored;
      await once(vR, "seeked").catch(() => {});
      show("R");
      await ensureFrame(vR);

      try { await vR.play(); } catch {}
    }

    // Make first idle frame black (no white flash) until first press
    show(null);

    // Pointer handling: capture so pointerup always fires even if DOM changes
    stage.addEventListener("pointerdown", async (e) => {
      e.preventDefault();
      holding = true;
      stage.setPointerCapture?.(e.pointerId);
      await playForwardFromStart();
    });

    stage.addEventListener("pointerup", async (e) => {
      e.preventDefault();
      holding = false;
      await playReverseFromMirroredTime();
    });

    stage.addEventListener("pointercancel", async () => {
      holding = false;
      await playReverseFromMirroredTime();
    });

    stage.addEventListener("pointerleave", async (e) => {
      if (holding && e.buttons) {
        holding = false;
        await playReverseFromMirroredTime();
      }
    });

    // Optional: preload one random anim on load to make first press instant
    (async () => {
      await loadPair(pickRandomAnim());
      // Keep hidden until interaction; background stays black
      show(null);
    })();
  </script>
</body>
</html>
