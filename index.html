<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Press → Forward, Release → Reverse</title>
  <style>
    html, body { margin: 0; height: 100%; background: transparent; }
    body { display: grid; place-items: center; }

    .wrap { width: min(360px, 90vw); }
    .stage {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      background: #000;           /* fallback is black (no white flash) */
      touch-action: manipulation;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Invisible sizer establishes aspect/height reliably */
    #sizer {
      position: relative;
      opacity: 0;
      pointer-events: none;
      width: 100%;
      height: auto;
      display: block;
    }

    /* Two stacked playback videos. They do NOT receive pointer events. */
    #vF, #vR {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: 0;
      pointer-events: none;
      background: #000;
    }
    #vF.is-on, #vR.is-on { opacity: 1; }

    .hint {
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity: 0.7;
      margin-top: 8px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage" aria-label="Press and hold">
      <video id="sizer" muted playsinline preload="metadata"></video>
      <video id="vF" muted playsinline preload="auto"></video>
      <video id="vR" muted playsinline preload="auto"></video>
    </div>
    <div class="hint">Press / hold to play → release to rewind</div>
  </div>

  <script>
    // Put 5–10 animation pairs here
    const ANIMS = [
      { fwd: "assets/anim1_fwd.mp4", rev: "assets/anim1_rev.mp4" },
      // { fwd: "assets/anim2_fwd.mp4", rev: "assets/anim2_rev.mp4" },
    ];

    const stage = document.getElementById("stage");
    const sizer = document.getElementById("sizer");
    const vF = document.getElementById("vF");
    const vR = document.getElementById("vR");

    let duration = 0;
    let holding = false;
    let prepared = false;
    let preparing = false;
    let currentPair = null;

    function pickRandomAnim() {
      return ANIMS[Math.floor(Math.random() * ANIMS.length)];
    }

    function once(el, evt) {
      return new Promise(res => el.addEventListener(evt, res, { once: true }));
    }

    async function ensurePaintableFrame(el) {
      // Wait for something likely paintable
      await Promise.race([once(el, "canplay"), once(el, "seeked")]).catch(() => {});
      if (typeof el.requestVideoFrameCallback === "function") {
        await new Promise(res => el.requestVideoFrameCallback(() => res()));
      } else {
        await new Promise(r => setTimeout(r, 20));
      }
    }

    function show(which) {
      vF.classList.toggle("is-on", which === "F");
      vR.classList.toggle("is-on", which === "R");
    }

    async function prepareNextPair(pair) {
      if (preparing) return;
      preparing = true;
      prepared = false;

      currentPair = pair;

      // Set sources (do NOT do this during the press; do it while idle)
      vF.src = pair.fwd;
      vR.src = pair.rev;
      sizer.src = pair.fwd;

      vF.load(); vR.load(); sizer.load();

      await once(vF, "loadedmetadata");
      duration = vF.duration || 0;

      // Prime both at frame 0
      vF.currentTime = 0;
      vR.currentTime = 0;

      // Stabilize layout + decoding
      await ensurePaintableFrame(sizer);
      await ensurePaintableFrame(vF);
      await ensurePaintableFrame(vR);

      // Idle state: show nothing (black background) until pressed
      show(null);

      prepared = true;
      preparing = false;
    }

    async function playForwardFromStart() {
      if (!prepared) return;           // if something is still loading, ignore
      vR.pause();
      vF.pause();
      vF.currentTime = 0;

      show("F");
      await ensurePaintableFrame(vF);

      // Must be called from a user gesture; pointerdown qualifies
      await vF.play();
    }

    async function playReverseFromMirroredTime() {
      if (!prepared || !duration) return;

      const t = Math.min(Math.max(vF.currentTime || 0, 0), duration);
      const mirrored = Math.max(0, Math.min(duration, duration - t));

      vF.pause();
      vR.pause();

      vR.currentTime = mirrored;
      await once(vR, "seeked").catch(() => {});
      show("R");
      await ensurePaintableFrame(vR);

      try { await vR.play(); } catch {}
    }

    // When reverse finishes rewinding to 0, hide + prep the next random pair
    function armNextOnReverseEnd() {
      const eps = 0.04; // seconds
      const handler = async () => {
        if (!holding && vR.currentTime <= eps) {
          vR.pause();
          show(null);
          vR.removeEventListener("timeupdate", handler);

          // Prepare the next random animation while idle (so next press is instant)
          await prepareNextPair(pickRandomAnim());
        }
      };
      vR.addEventListener("timeupdate", handler);
    }

    // Prevent any click/tap default behavior from the browser
    stage.addEventListener("click", (e) => e.preventDefault());

    stage.addEventListener("pointerdown", async (e) => {
      e.preventDefault();
      holding = true;
      stage.setPointerCapture?.(e.pointerId);

      // IMPORTANT: do NOT swap sources here. Just play what is already prepared.
      await playForwardFromStart();
    });

    stage.addEventListener("pointerup", async (e) => {
      e.preventDefault();
      holding = false;

      await playReverseFromMirroredTime();
      armNextOnReverseEnd();
    });

    stage.addEventListener("pointercancel", async () => {
      holding = false;
      await playReverseFromMirroredTime();
      armNextOnReverseEnd();
    });

    stage.addEventListener("pointerleave", async (e) => {
      if (holding && e.buttons) {
        holding = false;
        await playReverseFromMirroredTime();
        armNextOnReverseEnd();
      }
    });

    // Initial preload: pick one random pair and make it ready before first press
    (async () => {
      await prepareNextPair(pickRandomAnim());
    })();
  </script>
</body>
</html>
