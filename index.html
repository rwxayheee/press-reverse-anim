<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Press → Forward, Release → Reverse</title>
  <style>
    html, body { margin: 0; height: 100%; background: transparent; }
    body { display: grid; place-items: center; height: 100vh; background: transparent; }
    .wrap { width: min(360px, 90vw); }

    /* Lock the player box size so src swaps don't reflow (fixes the "black reset blink") */
    .stage {
      position: relative;
      width: 100%;
      border-radius: 16px;
      overflow: hidden;
      background: #000;
      touch-action: manipulation;
      user-select: none;
      /* default aspect ratio until we know the real one */
      aspect-ratio: var(--ar, 16 / 9);
    }
    /* Make the video fill the locked stage box */
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
      background: #000;
    }

    .hint { font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; opacity: 0.7; margin-top: 8px; text-align: center; }
    .status { font: 12px/1.3 system-ui; opacity: 0.7; text-align:center; margin-top: 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage">
      <video id="v" muted playsinline preload="auto"></video>
    </div>
    <div class="hint">Press / hold to play → release to rewind</div>
    <div class="status" id="status">Loading…</div>
  </div>

  <script>
    const ANIMS = [
      { fwd: "assets/anim1_fwd.mp4", rev: "assets/anim1_rev.mp4" },
      // { fwd: "assets/anim2_fwd.mp4", rev: "assets/anim2_rev.mp4" },
    ];
    const IDLE = "assets/anim_idle.mp4";

    const stage = document.getElementById("stage");
    const video  = document.getElementById("v");
    const status = document.getElementById("status");

    // Cache: src -> { url: blobObjectUrl, duration, w, h }
    const cache = new Map();

    let ready = false;
    let holding = false;
    let current = null;      // {fwd, rev}
    let duration = 0;

    function pickRandomAnim() {
      return ANIMS[Math.floor(Math.random() * ANIMS.length)];
    }

    function once(el, evt) {
      return new Promise(res => el.addEventListener(evt, res, { once: true }));
    }

    function setStageAspect(w, h) {
      // Guard against 0 values
      const W = (w && w > 0) ? w : 16;
      const H = (h && h > 0) ? h : 9;
      stage.style.setProperty("--ar", `${W} / ${H}`);
    }

    async function preloadOne(src) {
      if (cache.has(src)) return cache.get(src);

      const resp = await fetch(src, { cache: "force-cache" });
      if (!resp.ok) throw new Error("Failed to fetch " + src);
      const blob = await resp.blob();
      const url = URL.createObjectURL(blob);

      // Probe metadata off-gesture
      const probe = document.createElement("video");
      probe.muted = true;
      probe.playsInline = true;
      probe.preload = "auto";
      probe.src = url;
      probe.load();
      await once(probe, "loadedmetadata");

      const dur = probe.duration || 0;
      const w = probe.videoWidth || 0;
      const h = probe.videoHeight || 0;

      const entry = { url, duration: dur, w, h };
      cache.set(src, entry);
      return entry;
    }

    async function preloadAll() {
      status.textContent = "Loading…";
      // Preload idle first and start it immediately
      const idleEntry = await preloadOne(IDLE);
      setStageAspect(idleEntry.w, idleEntry.h);
      playIdleFromStart();

      const allSrcs = [];
      for (const a of ANIMS) allSrcs.push(a.fwd, a.rev);

      for (let i = 0; i < allSrcs.length; i++) {
        await preloadOne(allSrcs[i]);
        status.textContent = `Loading… ${i+1}/${allSrcs.length}`;
      }

      ready = true;
      status.textContent = "Ready ✅ (press to play)";
    }

    // ----- Interaction (NO awaits before play) -----

    function setSrcSync(srcEntry) {
      video.src = srcEntry.url;
      video.load();
    }

    function playIdleFromStart() {
      const idle = cache.get(IDLE);
      if (!idle) return;
      setStageAspect(idle.w, idle.h);
      video.loop = true;
      video.onended = null;
      setSrcSync(idle);
      try { video.currentTime = 0; } catch {}
      video.play().catch(() => {});
    }

    function playForwardFromStart() {
      current = pickRandomAnim();

      const fwd = cache.get(current.fwd);
      const rev = cache.get(current.rev);

      if (!fwd || !rev) return;

      duration = fwd.duration;

      // Lock aspect ratio BEFORE swapping src to prevent any reflow blink
      setStageAspect(fwd.w, fwd.h);

      setSrcSync(fwd);
      video.loop = false;
      video.onended = null;
      try { video.currentTime = 0; } catch {}
      video.play().catch(() => {});
    }

    function swapToReverseAtMirroredTime() {
      if (!current) return;

      const fwd = cache.get(current.fwd);
      const rev = cache.get(current.rev);
      if (!fwd || !rev) return;

      const dur = duration || fwd.duration || 0;
      const t = Math.min(Math.max(video.currentTime || 0, 0), dur);
      const mirrored = Math.max(0, dur - t);

      // Keep aspect stable (rev should match, but this is safe)
      setStageAspect(rev.w || fwd.w, rev.h || fwd.h);

      setSrcSync(rev);

      video.addEventListener("loadedmetadata", () => {
        video.loop = false;
        video.onended = () => { playIdleFromStart(); };
        try { video.currentTime = mirrored; } catch {}
        video.play().catch(() => {});
      }, { once: true });
    }

    // Pointer events
    stage.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      holding = true;
      stage.setPointerCapture?.(e.pointerId);

      if (!ready) return;
      playForwardFromStart();
    });

    stage.addEventListener("pointerup", (e) => {
      e.preventDefault();
      holding = false;
      if (!ready) return;
      swapToReverseAtMirroredTime();
    });

    stage.addEventListener("pointercancel", () => {
      holding = false;
      if (!ready) return;
      swapToReverseAtMirroredTime();
    });

    stage.addEventListener("pointerleave", (e) => {
      if (holding && e.buttons) {
        holding = false;
        if (!ready) return;
        swapToReverseAtMirroredTime();
      }
    });

    preloadAll().catch(err => {
      console.error(err);
      status.textContent = "Failed to load assets (check paths).";
    });
  </script>
</body>
</html>
