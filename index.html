<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Press → Forward, Release → Reverse</title>
  <style>
    html, body { margin: 0; height: 100%; background: transparent; }
    body { display: grid; place-items: center; }

    .wrap { width: min(360px, 90vw); }
    .stage { position: relative; border-radius: 16px; overflow: hidden; }

    /* Make sure any fallback paint is NOT white */
    .stage { background: #000; border-radius: 16px; overflow: hidden; }
    video, canvas {
      width: 100%;
      height: auto;
      background: #000;
      display: block;
    }

    /* Canvas overlay sits above video */
    #freeze {
      position: absolute;
      inset: 0;
      z-index: 2;
      width: 100%;
      height: 100%;
    }
    #v {
      position: relative;
      z-index: 1;
    }

    .hint {
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity: 0.7;
      margin-top: 8px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <video id="v" muted playsinline preload="auto" poster="assets/black.png"></video>
      <canvas id="freeze"></canvas>
    </div>
    <div class="hint">Press / hold to play → release to rewind</div>
  </div>

  <script>
    const ANIMS = [
      { fwd: "assets/anim1_fwd.mp4", rev: "assets/anim1_rev.mp4" },
      // { fwd: "assets/anim2_fwd.mp4", rev: "assets/anim2_rev.mp4" },
    ];

    const video = document.getElementById("v");
    const freeze = document.getElementById("freeze");
    const fctx = freeze.getContext("2d");

    const revPreload = document.createElement("video");
    revPreload.muted = true;
    revPreload.playsInline = true;
    revPreload.preload = "auto";

    let current = null;
    let duration = null;
    let holding = false;

    function pickRandomAnim() {
      return ANIMS[Math.floor(Math.random() * ANIMS.length)];
    }

    function waitOnce(el, name) {
      return new Promise(res => el.addEventListener(name, res, { once: true }));
    }

    function setFreezeSize() {
      // Match canvas pixel size to displayed STAGE size for crispness (more stable than video rect during src swaps)
      const stage = document.querySelector(".stage");
      const rect = stage.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      freeze.width = Math.max(1, Math.round(rect.width * dpr));
      freeze.height = Math.max(1, Math.round(rect.height * dpr));
    }

    window.addEventListener("resize", () => drawFreezeFrame());

    function drawFreezeFrame() {
      setFreezeSize();
      // Draw current video frame into the overlay
      try {
        fctx.clearRect(0, 0, freeze.width, freeze.height);
        fctx.drawImage(video, 0, 0, freeze.width, freeze.height);
      } catch {
        // If drawImage fails (no frame yet), just keep whatever was there
      }
      freeze.style.display = "block";
    }

    async function revealVideoWhenReady() {
      // Keep freeze visible until video can actually present a frame
      // 1) wait canplay OR seeked, whichever comes first
      // 2) on browsers that support it, wait for an actual video frame callback
      const canplayP = waitOnce(video, "canplay");
      const seekedP = waitOnce(video, "seeked");

      await Promise.race([canplayP, seekedP]).catch(() => {});
      if (typeof video.requestVideoFrameCallback === "function") {
        await new Promise(res => video.requestVideoFrameCallback(() => res()));
      } else {
        // small delay helps some browsers finish painting
        await new Promise(r => setTimeout(r, 20));
      }
      freeze.style.display = "none";
    }

    async function loadMeta(el, src) {
      el.src = src;
      el.load();
      await waitOnce(el, "loadedmetadata");
      return el.duration;
    }

    async function prepareAnimPair(anim) {
      // Freeze whatever is currently visible BEFORE we swap sources
      drawFreezeFrame();

      const [durF] = await Promise.all([
        loadMeta(video, anim.fwd),
        loadMeta(revPreload, anim.rev),
      ]);
      duration = durF;
      current = anim;

      video.currentTime = 0;
      video.pause();

      // Reveal once first frame is ready
      await revealVideoWhenReady();
    }

    async function playForwardFromStart() {
      const anim = pickRandomAnim();
      await prepareAnimPair(anim);

      // Freeze before play to avoid “empty paint” at start
      drawFreezeFrame();

      video.currentTime = 0;
      await video.play();
      await revealVideoWhenReady();
    }

    async function playReverseFromMirroredTime() {
      if (!current || !duration) return;

      const t = Math.min(Math.max(video.currentTime, 0), duration);
      const mirrored = Math.max(0, Math.min(duration, duration - t));

      // Freeze current visible frame BEFORE swapping src
      drawFreezeFrame();

      // Instant-ish swap to preloaded reverse
      video.src = revPreload.src;
      video.load();
      await waitOnce(video, "loadedmetadata");

      // Seek then play
      video.currentTime = mirrored;
      await waitOnce(video, "seeked").catch(() => {});
      try { await video.play(); } catch {}

      await revealVideoWhenReady();
    }

    const target = document.body;

    target.addEventListener("pointerdown", async (e) => {
      e.preventDefault();
      holding = true;
      await playForwardFromStart();
    });

    target.addEventListener("pointerup", async (e) => {
      e.preventDefault();
      holding = false;
      await playReverseFromMirroredTime();
    });

    target.addEventListener("pointercancel", async () => {
      holding = false;
      await playReverseFromMirroredTime();
    });

    target.addEventListener("pointerleave", async (e) => {
      if (holding && e.buttons) {
        holding = false;
        await playReverseFromMirroredTime();
      }
    });

    // Idle preload (shows first frame without flashing)
    (async () => {
      const anim = pickRandomAnim();
      await prepareAnimPair(anim);
      drawFreezeFrame();            // show a stable idle frame
      await revealVideoWhenReady(); // then remove overlay once truly ready
    })();
  </script>
</body>
</html>
