<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Press → Forward, Release → Reverse</title>
  <style>
    html, body { margin: 0; height: 100%; background: transparent; }
    body { display: grid; place-items: center; }

    .wrap { width: min(360px, 90vw); background: transparent; }
    .hint { font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; opacity: 0.7; margin-top: 8px; text-align: center; }

    /* IMPORTANT: prevent white flash */
    video {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 16px;
      background: transparent;   /* key */
    }
  </style>
</head>
<body>
  <div class="wrap">
    <video id="v" muted playsinline preload="auto"></video>
    <div class="hint">Press / hold to play → release to rewind</div>
  </div>

  <script>
    const ANIMS = [
      { fwd: "assets/anim1_fwd.mp4", rev: "assets/anim1_rev.mp4" },
      // { fwd: "assets/anim2_fwd.mp4", rev: "assets/anim2_rev.mp4" },
    ];

    const video = document.getElementById("v");

    let current = null;
    let duration = null;

    // Keep reverse preloaded so release doesn't "load" -> no blink
    const revPreload = document.createElement("video");
    revPreload.muted = true;
    revPreload.playsInline = true;
    revPreload.preload = "auto";

    function pickRandomAnim() {
      return ANIMS[Math.floor(Math.random() * ANIMS.length)];
    }

    function waitEvent(el, name) {
      return new Promise(res => el.addEventListener(name, res, { once: true }));
    }

    async function loadMeta(el, src) {
      el.src = src;
      el.load();
      await waitEvent(el, "loadedmetadata");
      return el.duration;
    }

    async function prepareAnimPair(anim) {
      // Load metadata for both in parallel
      const [durF] = await Promise.all([
        loadMeta(video, anim.fwd),
        loadMeta(revPreload, anim.rev),
      ]);
      duration = durF;
      current = anim;

      // Park both at start; video is the visible one
      video.currentTime = 0;
      video.pause();

      // Force first frame decode (reduces initial flicker on some browsers)
      try { await video.play(); } catch {}
      video.pause();
      video.currentTime = 0;
    }

    async function playForwardFromStart() {
      const anim = pickRandomAnim();
      await prepareAnimPair(anim);

      video.currentTime = 0;
      await video.play(); // user gesture (pointerdown) -> allowed
    }

    async function playReverseFromMirroredTime() {
      if (!current || !duration) return;

      const t = Math.min(Math.max(video.currentTime, 0), duration);
      const mirrored = Math.max(0, Math.min(duration, duration - t));

      // Swap to the already-preloaded reverse source (instant)
      video.src = revPreload.src;
      video.load();
      await waitEvent(video, "loadedmetadata"); // very fast; metadata is cached
      video.currentTime = mirrored;

      try { await video.play(); } catch {}
    }

    let holding = false;
    const target = document.body;

    target.addEventListener("pointerdown", async (e) => {
      e.preventDefault();
      holding = true;
      await playForwardFromStart();
    });

    target.addEventListener("pointerup", async (e) => {
      e.preventDefault();
      holding = false;
      await playReverseFromMirroredTime();
    });

    target.addEventListener("pointercancel", async () => {
      holding = false;
      await playReverseFromMirroredTime();
    });

    target.addEventListener("pointerleave", async (e) => {
      if (holding && e.buttons) {
        holding = false;
        await playReverseFromMirroredTime();
      }
    });

    // Idle preload so first press is snappy
    (async () => {
      const anim = pickRandomAnim();
      await prepareAnimPair(anim);
    })();
  </script>
</body>
</html>
