<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Press → Forward, Release → Reverse</title>
  <style>
    html, body { margin: 0; height: 100%; background: transparent; }
    body { display: grid; place-items: center; height: 100vh; background: transparent; }
    .wrap { width: min(360px, 90vw); }
    .stage { border-radius: 16px; overflow: hidden; background: #000; } /* black fallback */
    .hint { font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; opacity: 0.7; margin-top: 8px; text-align: center; }
    video { width: 100%; height: auto; display: block; background: #000; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <video id="v"
        muted
        playsinline
        preload="auto"
      ></video>
    </div>
    <div class="hint">Press / hold to play → release to rewind</div>
  </div>

  <script>
    // Add your 5–10 animation pairs here
    const ANIMS = [
      { fwd: "assets/anim1_fwd.mp4", rev: "assets/anim1_rev.mp4" },
      // { fwd: "assets/anim2_fwd.mp4", rev: "assets/anim2_rev.mp4" },
    ];

    const video = document.getElementById("v");

    // Cache of preloaded blob URLs: Map(src -> objectURL)
    const blobURL = new Map();

    let current = null;          // current anim pair
    let duration = 0;            // seconds
    let holding = false;

    function pickRandomAnim() {
      return ANIMS[Math.floor(Math.random() * ANIMS.length)];
    }

    function once(el, name) {
      return new Promise(res => el.addEventListener(name, res, { once: true }));
    }

    async function ensurePaintedFrame(el) {
      // Wait for a frame to be ready so we don't see a "blank" paint
      if (typeof el.requestVideoFrameCallback === "function") {
        await new Promise(res => el.requestVideoFrameCallback(() => res()));
      } else {
        // Fallback: a short delay usually avoids the flash
        await new Promise(r => setTimeout(r, 20));
      }
    }

    async function preloadToBlob(src) {
      if (blobURL.has(src)) return blobURL.get(src);

      const resp = await fetch(src, { cache: "force-cache" });
      if (!resp.ok) throw new Error("Failed to fetch " + src);
      const blob = await resp.blob();
      const url = URL.createObjectURL(blob);
      blobURL.set(src, url);
      return url;
    }

    async function setVideoSrcFromCache(src) {
      const url = await preloadToBlob(src);
      video.src = url;
      video.load();
      await once(video, "loadedmetadata");
      duration = video.duration || 0;
      await ensurePaintedFrame(video);
    }

    async function preparePair(pair) {
      // Preload both directions up front so swapping is instant and doesn't flash
      await Promise.all([preloadToBlob(pair.fwd), preloadToBlob(pair.rev)]);
    }

    async function playForwardFromStart() {
      current = pickRandomAnim();
      await preparePair(current);

      await setVideoSrcFromCache(current.fwd);
      video.currentTime = 0;
      // play() must be triggered from a user gesture; pointerdown counts.
      await video.play();
    }

    async function swapToReverseAtMirroredTime() {
      if (!current || !duration) return;

      const t = Math.min(Math.max(video.currentTime || 0, 0), duration);
      const mirrored = Math.max(0, Math.min(duration, duration - t));

      await setVideoSrcFromCache(current.rev);
      video.currentTime = mirrored;
      await once(video, "seeked").catch(() => {});
      try { await video.play(); } catch {}
    }

    // Pointer events cover mouse + touch + pen
    const target = document.querySelector(".stage");

    target.addEventListener("pointerdown", async (e) => {
      e.preventDefault();
      holding = true;
      target.setPointerCapture?.(e.pointerId);
      await playForwardFromStart();
    });

    target.addEventListener("pointerup", async (e) => {
      e.preventDefault();
      holding = false;
      await swapToReverseAtMirroredTime();
    });

    target.addEventListener("pointercancel", async () => {
      holding = false;
      await swapToReverseAtMirroredTime();
    });

    target.addEventListener("pointerleave", async (e) => {
      if (holding && e.buttons) {
        holding = false;
        await swapToReverseAtMirroredTime();
      }
    });

    // Idle preload (optional): preload first pair so first press is snappy
    (async () => {
      current = pickRandomAnim();
      await preparePair(current);
      await setVideoSrcFromCache(current.fwd);
      video.currentTime = 0;
      video.pause();
    })();
  </script>
</body>
</html>
