<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Press → Forward, Release → Reverse</title>
  <style>
    html, body { margin: 0; height: 100%; background: transparent; }
    body { display: grid; place-items: center; height: 100vh; background: transparent; }
    .wrap { width: min(360px, 90vw); }
    .stage { border-radius: 16px; overflow: hidden; background: #000; touch-action: manipulation; user-select: none; }
    .hint { font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; opacity: 0.7; margin-top: 8px; text-align: center; }
    video { width: 100%; height: auto; display: block; background: #000; }
    .status { font: 12px/1.3 system-ui; opacity: 0.7; text-align:center; margin-top: 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage">
      <video id="v" muted playsinline preload="auto"></video>
    </div>
    <div class="hint">Press / hold to play → release to rewind</div>
    <div class="status" id="status">Loading…</div>
  </div>

  <script>
    const ANIMS = [
      { fwd: "assets/anim1_fwd.mp4", rev: "assets/anim1_rev.mp4" },
      // { fwd: "assets/anim2_fwd.mp4", rev: "assets/anim2_rev.mp4" },
    ];

    const stage = document.getElementById("stage");
    const video  = document.getElementById("v");
    const status = document.getElementById("status");

    // Cache: src -> { url: blobObjectUrl, duration }
    const cache = new Map();

    let ready = false;
    let holding = false;
    let current = null;      // {fwd, rev}
    let duration = 0;

    function pickRandomAnim() {
      return ANIMS[Math.floor(Math.random() * ANIMS.length)];
    }

    function once(el, evt) {
      return new Promise(res => el.addEventListener(evt, res, { once: true }));
    }

    async function preloadOne(src) {
      if (cache.has(src)) return cache.get(src);

      const resp = await fetch(src, { cache: "force-cache" });
      if (!resp.ok) throw new Error("Failed to fetch " + src);
      const blob = await resp.blob();
      const url = URL.createObjectURL(blob);

      // Get duration using a hidden video element (NOT during user gesture)
      const probe = document.createElement("video");
      probe.muted = true;
      probe.playsInline = true;
      probe.preload = "auto";
      probe.src = url;
      probe.load();
      await once(probe, "loadedmetadata");
      const dur = probe.duration || 0;

      const entry = { url, duration: dur };
      cache.set(src, entry);
      return entry;
    }

    async function preloadAll() {
      status.textContent = "Loading…";
      const allSrcs = [];
      for (const a of ANIMS) allSrcs.push(a.fwd, a.rev);

      // Preload sequentially to be gentler; change to Promise.all if you want
      for (let i = 0; i < allSrcs.length; i++) {
        await preloadOne(allSrcs[i]);
        status.textContent = `Loading… ${i+1}/${allSrcs.length}`;
      }

      ready = true;
      status.textContent = "Ready ✅ (press to play)";
    }

    // ----- Interaction (NO awaits before play) -----

    function setSrcSync(srcEntry) {
      video.src = srcEntry.url;
      video.load();
    }

    function playForwardFromStart() {
      current = pickRandomAnim();

      const fwd = cache.get(current.fwd);
      const rev = cache.get(current.rev);

      if (!fwd || !rev) return; // not ready yet

      duration = fwd.duration;

      setSrcSync(fwd);
      // currentTime can be set immediately; browser will clamp once metadata lands
      try { video.currentTime = 0; } catch {}
      // Call play immediately inside gesture
      video.play().catch(() => {});
    }

    function swapToReverseAtMirroredTime() {
      if (!current) return;

      const fwd = cache.get(current.fwd);
      const rev = cache.get(current.rev);
      if (!fwd || !rev) return;

      const t = Math.min(Math.max(video.currentTime || 0, 0), duration || fwd.duration || 0);
      const mirrored = Math.max(0, (duration || fwd.duration || 0) - t);

      setSrcSync(rev);
      // Seek AFTER metadata is ready, but we do it via an event handler (no await)
      video.addEventListener("loadedmetadata", () => {
        try { video.currentTime = mirrored; } catch {}
        video.play().catch(() => {});
      }, { once: true });
    }

    // Pointer events
    stage.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      holding = true;
      stage.setPointerCapture?.(e.pointerId);

      if (!ready) return;
      playForwardFromStart();
    });

    stage.addEventListener("pointerup", (e) => {
      e.preventDefault();
      holding = false;
      if (!ready) return;
      swapToReverseAtMirroredTime();
    });

    stage.addEventListener("pointercancel", () => {
      holding = false;
      if (!ready) return;
      swapToReverseAtMirroredTime();
    });

    stage.addEventListener("pointerleave", (e) => {
      if (holding && e.buttons) {
        holding = false;
        if (!ready) return;
        swapToReverseAtMirroredTime();
      }
    });

    // Kick off preload at startup
    preloadAll().catch(err => {
      console.error(err);
      status.textContent = "Failed to load assets (check paths).";
    });
  </script>
</body>
</html>
