<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Press → Forward, Release → Reverse</title>
  <style>
    body { margin: 0; display: grid; place-items: center; height: 100vh; background: transparent; }
    .wrap { width: min(360px, 90vw); }
    .hint { font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; opacity: 0.7; margin-top: 8px; text-align: center; }
    video { width: 100%; height: auto; display: block; border-radius: 16px; }
  </style>
</head>
<body>
  <div class="wrap">
    <video id="v"
      muted
      playsinline
      preload="metadata"
      poster=""
    ></video>
    <div class="hint">Press / hold to play → release to rewind</div>
  </div>

  <script>
    // Add your 5–10 animation pairs here
    const ANIMS = [
      { fwd: "assets/anim1_fwd.mp4", rev: "assets/anim1_rev.mp4" },
      // { fwd: "assets/anim2_fwd.mp4", rev: "assets/anim2_rev.mp4" },
    ];

    const video = document.getElementById("v");

    let current = null;          // current anim pair
    let duration = null;         // seconds
    let holding = false;

    function pickRandomAnim() {
      return ANIMS[Math.floor(Math.random() * ANIMS.length)];
    }

    function waitEvent(el, name) {
      return new Promise(res => el.addEventListener(name, res, { once: true }));
    }

    async function loadSrc(src) {
      video.src = src;
      // Force load
      video.load();
      // Wait metadata so duration is known
      await waitEvent(video, "loadedmetadata");
      duration = video.duration;
    }

    async function playForwardFromStart() {
      current = pickRandomAnim();
      await loadSrc(current.fwd);
      video.currentTime = 0;
      // play() must be triggered from a user gesture; pointerdown counts.
      await video.play();
    }

    async function swapToReverseAtMirroredTime() {
      if (!current || !duration) return;
      const t = Math.min(Math.max(video.currentTime, 0), duration);
      const mirrored = Math.max(0, Math.min(duration, duration - t));

      await loadSrc(current.rev);

      // Seek after metadata is ready. Some browsers need a microtask tick.
      video.currentTime = mirrored;
      try { await video.play(); } catch {}
    }

    // Pointer events cover mouse + touch + pen
    const target = document.body;

    target.addEventListener("pointerdown", async (e) => {
      e.preventDefault();
      holding = true;
      // Pick a random animation each interaction
      await playForwardFromStart();
    });

    target.addEventListener("pointerup", async (e) => {
      e.preventDefault();
      holding = false;
      await swapToReverseAtMirroredTime();
    });

    target.addEventListener("pointercancel", async () => {
      holding = false;
      await swapToReverseAtMirroredTime();
    });

    // Optional: if user drags pointer out while holding, still reverse
    target.addEventListener("pointerleave", async (e) => {
      if (holding && e.buttons) {
        holding = false;
        await swapToReverseAtMirroredTime();
      }
    });

    // Initial idle state (optional): load first anim frame without playing
    (async () => {
      current = pickRandomAnim();
      await loadSrc(current.fwd);
      video.currentTime = 0;
      video.pause();
    })();
  </script>
</body>
</html>

